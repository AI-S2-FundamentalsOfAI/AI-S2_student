import pygame
import random


""" 
Author: David Isaacs Paternostro

This code is partially generated by chatGPT

Editing this code is tedious because of how crappy GPT-generated code is.

There are also some bugs when the mountain size is not a divisor of the WIDTH or if larger than WIDTH, which i don't want to fix

Full conversation can be found here https://chatgpt.com/share/67a0d02e-dde0-800d-b343-ae0c35ccaff3

"""

# pick
random.seed(16)


# Initialize pygame
pygame.init()

# Screen dimensions
WIDTH, HEIGHT = 1920, 1080

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
GRAY = (200, 200, 200)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)

# Bar properties
NUM_BARS = 480
BAR_WIDTH = WIDTH//NUM_BARS

# Player properties
PLAYER_COLOR = GREEN
PLAYER_RADIUS = 10

# Initialize screen
screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
pygame.display.set_caption("Mountain Range Game")

# Fonts
font = pygame.font.Font(None, 36)

# Generate a random mountain range
def generate_mountain():
    heights = [random.randint(100, HEIGHT // 2)]  # Start with a random initial height
    direction = random.choice([-1, 1])  # Random initial direction: -1 (down) or 1 (up)
    min_height = 100
    max_height = 800

    for _ in range(1, WIDTH // BAR_WIDTH):
        delta = 10
        if random.random() < 0.8 and not heights[-1] >= 800 and not heights[-1] <= min_height:
            next_height = heights[-1] + (delta * direction)
        else:
            direction *= -1
            next_height = heights[-1] + (delta * direction)

        next_height = max(min_height, min(max_height, next_height))
        heights.append(next_height)

    return heights

# Draw the mountain range
def draw_mountain(heights, full_view=False, player_pos=None):
    for i, height in enumerate(heights):
        x = i * BAR_WIDTH
        y = HEIGHT - height
        color = WHITE if not full_view and player_pos is not None and i not in [player_pos - 1, player_pos, player_pos + 1] else GRAY
        if not full_view and player_pos is not None:
            if i in [player_pos - 1, player_pos, player_pos + 1]:
                color = BLUE
        pygame.draw.rect(screen, color, (x, y, BAR_WIDTH, height))

# Draw the player
def draw_player(player_pos, heights):
    x = player_pos * BAR_WIDTH + BAR_WIDTH // 2
    y = HEIGHT - heights[player_pos] - PLAYER_RADIUS
    pygame.draw.circle(screen, PLAYER_COLOR, (x, y), PLAYER_RADIUS)

# Main function
def main():
    global WIDTH, HEIGHT, NUM_BARS, BAR_WIDTH, screen
    clock = pygame.time.Clock()
    heights = generate_mountain()
    pygame.key.set_repeat(500,50)
    player_pos = random.randint(0, NUM_BARS - 1)

    # UI elements
    step_size_box       = pygame.Rect(10, 10, 300, 40)
    toggle_mountain_box = pygame.Rect(10, 50, 300, 40)
    random_button_box   = pygame.Rect(10, 90, 300, 40)
    y_value_box         = pygame.Rect(10, 130, 300, 40)
    mountain_size_box   = pygame.Rect(10, 170, 300, 40)
    reset_box           = pygame.Rect(10, 210, 300, 40)

    mountain_size_box_active = False
    step_size_box_active = False

    stepsize = 1
    step_size_text = "Stepsize: " + str(stepsize)
    show_full_map = False
    reset_box_text = "Reset"
    mountain_size_text = "Mountain size: " + str(NUM_BARS)
    max_height = max(heights)  # Find the max height to display the distance
    attempts = 0

    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    try:
                        if step_size_box_active:
                            stepsize = int(step_size_text.split(": ")[1])
                            step_size_text = "Step size: " + str(stepsize)
                            step_size_box_active = False
                        if mountain_size_box_active:
                            NUM_BARS = int(mountain_size_text.split(": ")[1])
                            BAR_WIDTH = WIDTH // NUM_BARS  # Recalculate the bar width
                            heights = generate_mountain()  # Generate a new mountain with the new number of bars
                            max_height = max(heights)
                            mountain_size_text = "Mountain size: " + str(NUM_BARS)# Recalculate max height
                            mountain_size_box_active = False
                    except ValueError:
                        pass


                elif event.key == pygame.K_BACKSPACE:
                    step_size_text = step_size_text[:-1]
                elif event.key == pygame.K_LEFT:
                    player_pos = max(0, player_pos - stepsize)
                    attempts += 1
                elif event.key == pygame.K_RIGHT:
                    player_pos = min(NUM_BARS - 1, player_pos + stepsize)
                    attempts += 1
                else:
                    if step_size_box_active:
                        step_size_text += event.unicode
                    elif mountain_size_box_active:
                        mountain_size_text += event.unicode
            elif event.type == pygame.MOUSEBUTTONDOWN:
                if toggle_mountain_box.collidepoint(event.pos):
                    show_full_map = not show_full_map
                elif random_button_box.collidepoint(event.pos):
                    player_pos = random.randint(0, NUM_BARS - 1)
                    attempts += 1
                elif mountain_size_box.collidepoint(event.pos):  # Clicked inside the mountain size box
                    # Convert text to integer and update NUM_BARS
                    mountain_size_text = "Mountain size: "
                    mountain_size_box_active = True

                elif step_size_box.collidepoint(event.pos):  # Clicked inside the step size box
                    step_size_text = "Step size: "
                    step_size_box_active = True

            elif event.type == pygame.VIDEORESIZE:
                WIDTH, HEIGHT = event.w, event.h
                NUM_BARS = WIDTH // BAR_WIDTH  # Update NUM_BARS first
                BAR_WIDTH = WIDTH // NUM_BARS  # Recalculate BAR_WIDTH
                screen = pygame.display.set_mode((WIDTH, HEIGHT), pygame.RESIZABLE)
                heights = generate_mountain()  # Generate a new mountain
                player_pos = random.randint(0, NUM_BARS - 1)

        screen.fill(WHITE)

        # Draw mountain
        draw_mountain(heights, full_view=show_full_map, player_pos=player_pos)

        # Draw player
        draw_player(player_pos, heights)

        # Draw UI elements
        pygame.draw.rect(screen, BLACK, step_size_box, 2)
        pygame.draw.rect(screen, BLACK, toggle_mountain_box, 2)
        pygame.draw.rect(screen, BLACK, random_button_box, 2)
        pygame.draw.rect(screen, BLACK, y_value_box, 2)
        pygame.draw.rect(screen, BLACK, mountain_size_box, 2)

        input_surface = font.render(step_size_text, True, BLACK)
        screen.blit(input_surface, (step_size_box.x + 5, step_size_box.y + 5))

        button_text = font.render("Toggle Map", True, BLACK)
        screen.blit(button_text, (toggle_mountain_box.x + 5, toggle_mountain_box.y + 5))

        random_button_text = font.render("Random Position", True, BLACK)
        screen.blit(random_button_text, (random_button_box.x + 5, random_button_box.y + 5))

        y_value_text = font.render(f"Y: {HEIGHT - heights[player_pos]}", True, BLACK)
        screen.blit(y_value_text, (y_value_box.x + 5, y_value_box.y + 5))

        # Display the distance from the highest bar
        height_diff = max_height - heights[player_pos]
        height_diff_text = font.render(f"Distance to highest: {height_diff}", True, BLACK)
        screen.blit(height_diff_text, (WIDTH - 300, 10))

        attempts_text = font.render(f"Attemps: {attempts}", True, BLACK)
        screen.blit(attempts_text, (WIDTH - 300, 40))



        mountain_size_input_surface = font.render(mountain_size_text, True, BLACK)
        screen.blit(mountain_size_input_surface, (mountain_size_box.x + 5, mountain_size_box.y + 5))

        pygame.display.flip()
        clock.tick(30)

    pygame.quit()

if __name__ == "__main__":
    main()
